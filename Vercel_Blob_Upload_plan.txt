# VERCEL BLOB UPLOAD IMPLEMENTATION PLAN

## CONTEXT

This is a Next.js app deployed on Vercel. Current file uploads hit Vercel's 4.5MB serverless function body limit. We're switching to Vercel Blob client uploads which bypass this limit entirely.

**Key facts about this codebase:**
- Alert system exists at `app/shared/alerts.ts` using SweetAlert2 with `showAlert()` function
- `@vercel/blob` is already installed
- Monorepo using pnpm

**Requirements:**
- Maximum uploaded file size: 30MB (enforced client-side AND server-side)
- Allowed file types: `.txt`, `.docx`, `.epub`, `.pdf`, `.html`
- After upload completes, copy file from Blob storage to user's GitHub repo
- Delete from Blob storage after successful GitHub copy (Blob is just a transit point)

---

## STEP 1: ENVIRONMENT VARIABLE

The `BLOB_READ_WRITE_TOKEN` env var was added to `.env.local`.

The `GITHUB_PAT` env var already exists in this project.

---

## STEP 2: CREATE BLOB UPLOAD API ROUTE

Create new file: `app/api/upload/route.ts`

```typescript
import { handleUpload, type HandleUploadBody } from '@vercel/blob/client';
import { del } from '@vercel/blob';
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth'; // ADJUST PATH: find where authOptions is exported

const MAX_FILE_SIZE = 30 * 1024 * 1024; // 30MB

const ALLOWED_CONTENT_TYPES = [
  'text/plain',                                                              // .txt
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document', // .docx
  'application/epub+zip',                                                    // .epub
  'application/pdf',                                                         // .pdf
  'application/[???]',                                                       // .html
];

export async function POST(request: NextRequest): Promise<NextResponse> {
  const body = (await request.json()) as HandleUploadBody;

  try {
    const jsonResponse = await handleUpload({
      body,
      request,
      onBeforeGenerateToken: async (pathname: string) => {
        // Get Google session
        const session = await getServerSession(authOptions);
        if (!session?.user) {
          throw new Error('Not authenticated');
        }

        // Extract googleId from session
        // ADJUST THIS: check how googleId is stored in your session
        // It might be session.user.id, session.googleId, or similar
        const googleId = (session.user as any).id || (session as any).googleId;
        
        if (!googleId) {
          throw new Error('Could not determine user identity');
        }

        // Validate file extension
        const ext = pathname.toLowerCase().slice(pathname.lastIndexOf('.'));
        const allowedExtensions = ['.txt', '.docx', '.epub', '.pdf'];
        if (!allowedExtensions.includes(ext)) {
          throw new Error(`File type ${ext} not allowed. Allowed: ${allowedExtensions.join(', ')}`);
        }

        return {
          allowedContentTypes: ALLOWED_CONTENT_TYPES,
          maximumSizeInBytes: MAX_FILE_SIZE,
          tokenPayload: JSON.stringify({ googleId }),
        };
      },

      onUploadCompleted: async ({ blob, tokenPayload }) => {
        // This runs AFTER file is in Blob storage
        // Now copy to user's GitHub repo, then delete from Blob
        
        try {
          const { googleId } = JSON.parse(tokenPayload || '{}');
          
          if (!googleId) {
            console.error('No googleId in tokenPayload');
            return;
          }

          const githubToken = process.env.GITHUB_PAT;
          if (!githubToken) {
            console.error('GITHUB_PAT not configured');
            return;
          }

          // ADJUST THIS: find how GITHUB_OWNER is referenced elsewhere in your app
          // It might be an env var or hardcoded constant
          const owner = process.env.GITHUB_OWNER || 'YOUR_GITHUB_USERNAME';
          const repo = `${googleId}_proselenos`;

          // Fetch file from Blob storage
          const fileResponse = await fetch(blob.url);
          const fileBuffer = await fileResponse.arrayBuffer();
          const base64Content = Buffer.from(fileBuffer).toString('base64');

          // Extract filename
          const filename = blob.pathname.split('/').pop() || 'uploaded-file';
          
          // ADJUST THIS: set the path within the repo where uploads should go
          const githubPath = `uploads/${filename}`;

          // Check if file already exists (need SHA to update)
          let existingSha: string | undefined;
          try {
            const existingResponse = await fetch(
              `https://api.github.com/repos/${owner}/${repo}/contents/${githubPath}`,
              {
                headers: {
                  Authorization: `Bearer ${githubToken}`,
                  Accept: 'application/vnd.github.v3+json',
                },
              }
            );
            if (existingResponse.ok) {
              const data = await existingResponse.json();
              existingSha = data.sha;
            }
          } catch {
            // File doesn't exist, that's fine
          }

          // Create or update file in GitHub
          const githubResponse = await fetch(
            `https://api.github.com/repos/${owner}/${repo}/contents/${githubPath}`,
            {
              method: 'PUT',
              headers: {
                Authorization: `Bearer ${githubToken}`,
                Accept: 'application/vnd.github.v3+json',
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                message: `Upload: ${filename}`,
                content: base64Content,
                ...(existingSha && { sha: existingSha }),
              }),
            }
          );

          if (githubResponse.ok) {
            console.log(`Successfully copied ${filename} to GitHub repo ${repo}`);
            
            // Clean up - delete from Blob storage
            // Blob is just a transit point, no need to keep files there
            try {
              await del(blob.url);
              console.log(`Deleted ${filename} from Blob storage`);
            } catch (delError) {
              console.error('Failed to delete from Blob:', delError);
              // Non-fatal, file just stays in Blob
            }
          } else {
            const errorText = await githubResponse.text();
            console.error('GitHub upload failed:', errorText);
            // Don't delete from Blob if GitHub push failed
            // Leaves file in Blob for manual recovery if needed
          }

        } catch (error) {
          console.error('onUploadCompleted error:', error);
          // Don't throw - upload already succeeded, just log the error
        }
      },
    });

    return NextResponse.json(jsonResponse);
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Upload failed';
    return NextResponse.json({ error: message }, { status: 400 });
  }
}
```

**IMPORTANT - Things to adjust in this file:**
1. `authOptions` import path - find where this is exported in the codebase
2. `googleId` extraction - check how it's stored in the session object
3. `owner` - find how GitHub username is referenced elsewhere in app
4. `githubPath` - adjust folder structure if uploads shouldn't go to `uploads/`

**TIP:** Search codebase for existing GitHub API calls to see patterns already used.

---

## STEP 3: CREATE CLIENT UPLOAD COMPONENT

Create new file: `app/components/FileUploader.tsx`

```typescript
'use client';

import { useState, useRef } from 'react';
import { upload } from '@vercel/blob/client';
import { showAlert } from '@/app/shared/alerts';

const MAX_FILE_SIZE = 30 * 1024 * 1024; // 30MB
const ALLOWED_EXTENSIONS = ['.txt', '.docx', '.epub', '.pdf'];

interface FileUploaderProps {
  isDarkMode?: boolean;
  onUploadComplete?: (url: string, filename: string) => void;
  onUploadError?: (error: string) => void;
}

export default function FileUploader({
  isDarkMode = true,
  onUploadComplete,
  onUploadError,
}: FileUploaderProps) {
  const [isUploading, setIsUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const inputRef = useRef<HTMLInputElement>(null);

  const validateFile = (file: File): boolean => {
    // Check size
    if (file.size > MAX_FILE_SIZE) {
      const sizeMB = (file.size / 1024 / 1024).toFixed(1);
      showAlert(
        `File is too large (${sizeMB}MB).\nMaximum allowed is 30MB.`,
        'error',
        'Upload Failed',
        isDarkMode
      );
      return false;
    }

    // Check extension
    const ext = file.name.toLowerCase().slice(file.name.lastIndexOf('.'));
    if (!ALLOWED_EXTENSIONS.includes(ext)) {
      showAlert(
        `File type "${ext}" is not supported.\nAllowed types: ${ALLOWED_EXTENSIONS.join(', ')}`,
        'warning',
        'Invalid File Type',
        isDarkMode
      );
      return false;
    }

    return true;
  };

  const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    // Reset input so same file can be selected again
    if (inputRef.current) {
      inputRef.current.value = '';
    }

    // Validate BEFORE any upload attempt
    if (!validateFile(file)) {
      return;
    }

    setIsUploading(true);
    setUploadProgress(0);

    try {
      const blob = await upload(file.name, file, {
        access: 'public',
        handleUploadUrl: '/api/upload',
        onUploadProgress: (progress) => {
          setUploadProgress(Math.round(progress.percentage));
        },
      });

      showAlert(
        `File "${file.name}" uploaded successfully!`,
        'success',
        'Upload Complete',
        isDarkMode
      );

      onUploadComplete?.(blob.url, file.name);
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Upload failed';
      showAlert(
        `Failed to upload file.\n${message}`,
        'error',
        'Upload Error',
        isDarkMode
      );
      onUploadError?.(message);
    } finally {
      setIsUploading(false);
      setUploadProgress(0);
    }
  };

  return (
    <div className="file-uploader">
      <input
        ref={inputRef}
        type="file"
        accept=".txt,.docx,.epub,.pdf"
        onChange={handleFileSelect}
        disabled={isUploading}
        style={{ display: 'none' }}
        id="blob-file-upload-input"
      />
      <label
        htmlFor="blob-file-upload-input"
        style={{
          display: 'inline-block',
          padding: '10px 20px',
          backgroundColor: isUploading ? '#666' : '#3085d6',
          color: '#fff',
          borderRadius: '5px',
          cursor: isUploading ? 'not-allowed' : 'pointer',
          transition: 'background-color 0.2s',
        }}
      >
        {isUploading ? `Uploading... ${uploadProgress}%` : 'Upload File'}
      </label>
      <p style={{ marginTop: '8px', fontSize: '12px', color: '#888' }}>
        Allowed: .txt, .docx, .epub, .pdf (max 30MB)
      </p>
    </div>
  );
}
```

---

## STEP 4: INTEGRATE INTO EXISTING UI

Find where the current upload functionality lives. Replace or add the new component:

```typescript
import FileUploader from '@/app/components/FileUploader';

// In your JSX:
<FileUploader
  isDarkMode={true}  // or pull from your theme context/state
  onUploadComplete={(url, filename) => {
    console.log('Uploaded:', filename, 'URL:', url);
    // Add any post-upload logic here
  }}
  onUploadError={(error) => {
    console.error('Upload failed:', error);
  }}
/>
```

**Alternative:** If you prefer to integrate the upload logic into an existing component rather than using this new component, extract the `validateFile` function and the `upload()` call pattern from above.

---

## FILES SUMMARY

| File | Action |
|------|--------|
| `.env.local` | Add BLOB_READ_WRITE_TOKEN |
| `app/api/upload/route.ts` | NEW |
| `app/components/FileUploader.tsx` | NEW |
| Existing upload UI component | MODIFY to use FileUploader |

---

## THINGS CLAUDE CODE MUST FIND IN CODEBASE

Before writing the code, search for these patterns:

1. **authOptions location:**
   ```bash
   grep -r "authOptions" --include="*.ts" --include="*.tsx"
   ```

2. **How googleId is stored in session:**
   ```bash
   grep -r "googleId\|user\.id" --include="*.ts" --include="*.tsx"
   ```

3. **Existing GitHub API calls (to match patterns):**
   ```bash
   grep -r "api.github.com" --include="*.ts" --include="*.tsx"
   ```

4. **How GITHUB_OWNER or username is referenced:**
   ```bash
   grep -r "GITHUB_OWNER\|github.*owner" --include="*.ts" --include="*.tsx"
   ```

5. **Current upload component (to know what to replace):**
   ```bash
   grep -r "type=\"file\"\|input.*file\|upload" --include="*.tsx"
   ```

---

==== IMPORTANT ====
## FLOW SUMMARY

```
User selects file
       ↓
Client validates size ≤ 30MB? → No → showAlert error, stop
       ↓ Yes
Client validates extension? → No → showAlert warning, stop
       ↓ Yes
Browser calls /api/upload (onBeforeGenerateToken)
       ↓
Server validates session, returns upload token
       ↓
Browser uploads directly to Blob (bypasses 4.5MB limit)
       ↓
Vercel calls /api/upload (onUploadCompleted)
       ↓
Server fetches file from Blob
       ↓
Server pushes to GitHub repo: ${googleId}_proselenos
       ↓
GitHub success? → No → Log error, keep file in Blob for recovery
       ↓ Yes
Server deletes file from Blob
       ↓
Done - Blob storage stays at ~0 bytes
```

---

## POTENTIAL ISSUES

**File naming collisions:** Current code uses original filename. If same user uploads "chapter1.txt" twice, the second overwrites the first in their repo (which may be desired). Consider prefixing with timestamp if not:
   ```typescript
   const filename = `${Date.now()}-${blob.pathname.split('/').pop()}`;
   ```

---
THE END

cd /Users/cleesmith/proselenos/apps/proselenos-app && npx tsc --noEmit 2>&1 | head -50

npx tsc --noEmit 2>&1 | head -50


NEW FILES:
  1. apps/proselenos-app/src/app/api/upload/route.ts
  2. apps/proselenos-app/src/app/api/delete-blob/route.ts

  MODIFIED FILES:
  1. apps/proselenos-app/src/lib/github-project-actions.ts
    - Added copyBlobToProjectAction function
    - Modified uploadFileToProjectAction to allow .html
    - Multiple import changes (now back to original minus the del import)
  2. apps/proselenos-app/src/app/projects/FilesModal.tsx
    - Added .html to allowed extensions in 4 places
  3. apps/proselenos-app/src/app/projects/useProjectManager.ts
    - Added import { upload } from '@vercel/blob/client'
    - Added import { copyBlobToProjectAction }
    - Changed performFileUpload to use two-step blob flow
    - Changed max size to use env var (was hardcoded 25MB)

